"""
Java Properties file handler
"""

import os
import re
from typing import Dict, Any, Optional


def read_properties_file(file_path: str) -> Dict[str, str]:
    """
    Read a Java Properties file and return its content as a dictionary.
    
    Args:
        file_path: Path to the Properties file
        
    Returns:
        Dictionary containing the Properties file content
        
    Raises:
        FileNotFoundError: If the file doesn't exist
        ValueError: If the file is not valid Properties format
    """
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Properties file not found: {file_path}")
    
    properties = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.rstrip('\n\r')
                
                # Skip empty lines and comments
                if not line or line.startswith('#') or line.startswith('!'):
                    continue
                
                # Handle line continuation (lines ending with \)
                while line.endswith('\\'):
                    try:
                        next_line = next(f).rstrip('\n\r')
                        line = line[:-1] + next_line
                    except StopIteration:
                        break
                
                # Split on first = or :
                if '=' in line:
                    key, value = line.split('=', 1)
                elif ':' in line:
                    key, value = line.split(':', 1)
                else:
                    continue
                
                key = key.strip()
                value = value.strip()
                
                if key:
                    # Unescape the value
                    properties[key] = _unescape_properties_value(value)
    
    except UnicodeDecodeError:
        # Try with latin-1 encoding
        with open(file_path, 'r', encoding='latin-1') as f:
            for line_num, line in enumerate(f, 1):
                line = line.rstrip('\n\r')
                
                if not line or line.startswith('#') or line.startswith('!'):
                    continue
                
                while line.endswith('\\'):
                    try:
                        next_line = next(f).rstrip('\n\r')
                        line = line[:-1] + next_line
                    except StopIteration:
                        break
                
                if '=' in line:
                    key, value = line.split('=', 1)
                elif ':' in line:
                    key, value = line.split(':', 1)
                else:
                    continue
                
                key = key.strip()
                value = value.strip()
                
                if key:
                    properties[key] = _unescape_properties_value(value)
    
    return properties


def write_properties_file(file_path: str, content: Dict[str, str], 
                         header: Optional[str] = None) -> None:
    """
    Write content to a Java Properties file.
    
    Args:
        file_path: Path where to write the Properties file
        content: Dictionary containing the Properties content
        header: Optional header comment to add to the file
        
    Raises:
        ValueError: If content is not a valid dictionary
    """
    if not isinstance(content, dict):
        raise ValueError("Properties content must be a dictionary")
    
    # Ensure the directory exists
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    with open(file_path, 'w', encoding='utf-8') as f:
        # Write header if provided
        if header:
            f.write(f"# {header}\n")
            f.write(f"# Generated by algebras-cli\n\n")
        
        # Write properties
        for key, value in content.items():
            if isinstance(value, str):
                escaped_key = _escape_properties_key(key)
                escaped_value = _escape_properties_value(value)
                f.write(f"{escaped_key}={escaped_value}\n")


def extract_translatable_strings(properties_content: Dict[str, str]) -> Dict[str, str]:
    """
    Extract translatable strings from Properties content.
    
    Args:
        properties_content: Properties file content as dictionary
        
    Returns:
        Dictionary of key-value pairs for translatable strings
    """
    # All properties are considered translatable strings
    return properties_content.copy()


def create_properties_from_translations(translations: Dict[str, str], 
                                      header: Optional[str] = None) -> Dict[str, str]:
    """
    Create Properties content from translations.
    
    Args:
        translations: Dictionary of key-value translation pairs
        header: Optional header comment
        
    Returns:
        Properties content dictionary
    """
    return translations.copy()


def _escape_properties_key(key: str) -> str:
    """
    Escape a Properties key for writing.
    
    Args:
        key: Key to escape
        
    Returns:
        Escaped key
    """
    # Escape special characters in keys
    key = key.replace('\\', '\\\\')
    key = key.replace(' ', '\\ ')
    key = key.replace('=', '\\=')
    key = key.replace(':', '\\:')
    key = key.replace('#', '\\#')
    key = key.replace('!', '\\!')
    return key


def _escape_properties_value(value: str) -> str:
    """
    Escape a Properties value for writing.
    
    Args:
        value: Value to escape
        
    Returns:
        Escaped value
    """
    # Escape special characters in values
    value = value.replace('\\', '\\\\')
    value = value.replace('\n', '\\n')
    value = value.replace('\r', '\\r')
    value = value.replace('\t', '\\t')
    value = value.replace(' ', '\\ ')
    value = value.replace('=', '\\=')
    value = value.replace(':', '\\:')
    value = value.replace('#', '\\#')
    value = value.replace('!', '\\!')
    return value


def _unescape_properties_value(value: str) -> str:
    """
    Unescape a Properties value when reading.
    
    Args:
        value: Value to unescape
        
    Returns:
        Unescaped value
    """
    # Handle unicode escapes (\uXXXX)
    value = re.sub(r'\\u([0-9a-fA-F]{4})', 
                   lambda m: chr(int(m.group(1), 16)), value)
    
    # Handle other escapes
    value = value.replace('\\n', '\n')
    value = value.replace('\\r', '\r')
    value = value.replace('\\t', '\t')
    value = value.replace('\\ ', ' ')
    value = value.replace('\\=', '=')
    value = value.replace('\\:', ':')
    value = value.replace('\\#', '#')
    value = value.replace('\\!', '!')
    value = value.replace('\\\\', '\\')
    
    return value


def is_valid_properties_file(file_path: str) -> bool:
    """
    Check if a file is a valid Properties file.
    
    Args:
        file_path: Path to the file to check
        
    Returns:
        True if the file is a valid Properties file, False otherwise
    """
    try:
        content = read_properties_file(file_path)
        return isinstance(content, dict)
    except (FileNotFoundError, ValueError, UnicodeDecodeError):
        return False


def get_properties_language_code(file_path: str) -> Optional[str]:
    """
    Extract language code from Properties file path.
    
    Args:
        file_path: Path to the Properties file
        
    Returns:
        Language code if found, None otherwise
    """
    # Try to extract from filename (e.g., messages_en.properties -> en, messages_en_US.properties -> en_US)
    filename = os.path.basename(file_path)
    if '_' in filename:
        parts = filename.split('_')
        if len(parts) >= 2:
            # Get the part before .properties (last part)
            name_part = parts[-1].split('.')[0]
            # Check if it looks like a valid language code (2-3 letters)
            if len(name_part) in [2, 3] and name_part.isalpha():
                # Check if the previous part forms a valid locale (e.g., en_US)
                # Locale format: lowercase 2-letter language code + underscore + 2 uppercase letters (country code)
                if len(parts) >= 3:
                    second_last = parts[-2]
                    # Validate locale: language code should be lowercase 2 letters, country code should be uppercase 2 letters
                    if (len(second_last) == 2 and second_last.islower() and second_last.isalpha() and 
                        len(name_part) == 2 and name_part.isupper() and name_part.isalpha()):
                        return f"{second_last}_{name_part}"
                # Return just the language code (can be any case, but typically lowercase)
                return name_part
    
    return None
